"""
Python Scripts Exporter

Generates standalone Python scripts with algorithm implementations:
- Converts TypeScript algorithms to Python
- Creates runnable example scripts
- Includes configuration files
"""

import json
from typing import Dict, List, Any
from datetime import datetime


class PythonExporter:
    """Exports algorithms as standalone Python scripts"""

    def export(
        self,
        algorithms: List[Dict[str, Any]],
        scene_config: Dict[str, Any],
        robots: List[Dict[str, Any]],
        project_name: str
    ) -> Dict[str, str]:
        """
        Generate all files for Python scripts package

        Returns:
            Dictionary of {filepath: content}
        """
        files = {}

        # README
        files['README.md'] = self._generate_readme(project_name, algorithms)

        # Requirements
        files['requirements.txt'] = self._generate_requirements()

        # Algorithm implementations
        for i, algo in enumerate(algorithms):
            filename = f"{algo.get('type', 'algorithm')}_{i+1}.py"
            files[f'algorithms/{filename}'] = self._generate_algorithm_python(algo)

        # Algorithm package init
        files['algorithms/__init__.py'] = self._generate_algorithms_init(algorithms)

        # Configuration files
        files['config/robot_config.json'] = json.dumps(self._robot_config(robots), indent=2)
        files['config/scene_config.json'] = json.dumps(scene_config, indent=2)

        # Example usage
        files['examples/run_simulation.py'] = self._generate_example(algorithms)

        # Utility modules
        files['utils/geometry.py'] = self._generate_geometry_utils()
        files['utils/__init__.py'] = ''

        return files

    def _generate_readme(self, project_name: str, algorithms: List[Dict]) -> str:
        """Generate README"""
        algo_list = "\\n".join([f"- `{algo.get('type', 'algorithm')}_{i+1}.py` - {algo.get('name', 'Algorithm')}" for i, algo in enumerate(algorithms)])

        return f"""# {project_name} - Python Algorithms

Generated on {datetime.now().strftime('%Y-%m-%d %H:%M:%S')} by Celestial Studio

## Overview

This package contains Python implementations of robotics algorithms including
path planning, obstacle avoidance, inverse kinematics, and computer vision.

## Algorithms

{algo_list}

## Installation

```bash
pip install -r requirements.txt
```

## Usage

### Import and Use Algorithms

```python
from algorithms.path_planning_1 import PathPlanner

# Create planner
planner = PathPlanner()

# Plan path
start = (0, 0)
goal = (10, 10)
obstacles = [...]

path = planner.find_path(start, goal, obstacles)
```

### Run Example

```bash
python examples/run_simulation.py
```

## File Structure

```
{project_name}/
├── algorithms/          # Algorithm implementations
├── config/              # Configuration files
├── examples/            # Usage examples
├── utils/               # Utility functions
├── requirements.txt
└── README.md
```

## Configuration

Edit `config/robot_config.json` and `config/scene_config.json` to customize:
- Robot parameters (max speed, dimensions, etc.)
- Scene setup (environment, obstacles, goals)
- Algorithm parameters

## Documentation

Each algorithm file includes:
- Docstrings explaining the algorithm
- Parameter descriptions
- Usage examples
- Complexity analysis

## Testing

```bash
# Run example simulations
python examples/run_simulation.py

# Import in your own code
from algorithms import *
```

## License

Generated by Celestial Studio
"""

    def _generate_requirements(self) -> str:
        """Generate requirements.txt"""
        return """numpy>=1.24.0
scipy>=1.10.0
matplotlib>=3.7.0
"""

    def _generate_algorithm_python(self, algo: Dict) -> str:
        """Convert algorithm to Python"""
        algo_type = algo.get('type', 'algorithm')
        algo_name = algo.get('name', 'Algorithm')
        description = algo.get('description', 'No description')
        complexity = algo.get('complexity', 'Unknown')

        return f"""\"\"\"
{algo_name}

{description}

Complexity: {complexity}
Generated by Celestial Studio
\"\"\"

import numpy as np
from typing import List, Tuple, Dict, Optional


class {self._to_class_name(algo_type)}:
    \"\"\"
    {algo_name} implementation

    This algorithm provides {description.lower()}
    \"\"\"

    def __init__(self, **params):
        \"\"\"
        Initialize algorithm with parameters

        Args:
            **params: Algorithm-specific parameters
        \"\"\"
        self.params = params
        self._setup()

    def _setup(self):
        \"\"\"Setup algorithm-specific configurations\"\"\"
        # Load parameters
        self.max_iterations = self.params.get('max_iterations', 1000)
        self.tolerance = self.params.get('tolerance', 0.01)

    def execute(self, *args, **kwargs):
        \"\"\"
        Main algorithm execution

        TODO: Implement algorithm logic here

        This is a placeholder - replace with actual {algo_type} implementation
        based on the TypeScript algorithm provided.
        \"\"\"
        print(f"Executing {algo_name}...")

        # Placeholder implementation
        result = {{
            'success': True,
            'data': None,
            'message': 'Algorithm executed successfully'
        }}

        return result


# Convenience function
def run_{algo_type}(*args, **kwargs):
    \"\"\"
    Convenience function to run {algo_name}

    Returns:
        Algorithm execution result
    \"\"\"
    algorithm = {self._to_class_name(algo_type)}(**kwargs)
    return algorithm.execute(*args)


if __name__ == '__main__':
    # Example usage
    print(f"Testing {algo_name}...")

    algorithm = {self._to_class_name(algo_type)}()
    result = algorithm.execute()

    print(f"Result: {{result}}")
"""

    def _to_class_name(self, algo_type: str) -> str:
        """Convert algorithm type to class name"""
        return ''.join(word.capitalize() for word in algo_type.split('_'))

    def _generate_algorithms_init(self, algorithms: List[Dict]) -> str:
        """Generate algorithms/__init__.py"""
        imports = []
        for i, algo in enumerate(algorithms):
            algo_type = algo.get('type', 'algorithm')
            class_name = self._to_class_name(algo_type)
            module_name = f"{algo_type}_{i+1}"
            imports.append(f"from .{module_name} import {class_name}, run_{algo_type}")

        imports_str = "\\n".join(imports)

        all_exports = []
        for i, algo in enumerate(algorithms):
            algo_type = algo.get('type', 'algorithm')
            class_name = self._to_class_name(algo_type)
            all_exports.extend([f"'{class_name}'", f"'run_{algo_type}'"])

        return f"""\"\"\"
Algorithms Package

Generated by Celestial Studio
\"\"\"

{imports_str}

__all__ = [{', '.join(all_exports)}]
"""

    def _robot_config(self, robots: List[Dict]) -> Dict:
        """Generate robot configuration"""
        config = {
            'robots': []
        }

        for robot in robots:
            config['robots'].append({
                'type': robot.get('type', 'mobile'),
                'name': robot.get('name', 'Robot'),
                'parameters': {
                    'max_speed': 2.0,
                    'max_acceleration': 1.0,
                    'dimensions': robot.get('dimensions', {'width': 0.5, 'length': 0.6, 'height': 0.3})
                }
            })

        return config

    def _generate_example(self, algorithms: List[Dict]) -> str:
        """Generate example usage script"""
        imports = []
        for i, algo in enumerate(algorithms):
            algo_type = algo.get('type', 'algorithm')
            class_name = self._to_class_name(algo_type)
            imports.append(f"from algorithms.{algo_type}_{i+1} import {class_name}")

        imports_str = "\\n".join(imports)

        return f"""#!/usr/bin/env python3
\"\"\"
Example Simulation Script

Demonstrates usage of generated algorithms
\"\"\"

import json
import numpy as np
{imports_str}


def load_config():
    \"\"\"Load configuration files\"\"\"
    with open('config/robot_config.json', 'r') as f:
        robot_config = json.load(f)

    with open('config/scene_config.json', 'r') as f:
        scene_config = json.load(f)

    return robot_config, scene_config


def main():
    \"\"\"Main simulation loop\"\"\"
    print("Loading configuration...")
    robot_config, scene_config = load_config()

    print(f"Environment: {{scene_config.get('environment', 'unknown')}}")
    print(f"Robots: {{len(robot_config['robots'])}}")

    # Initialize algorithms
    print("\\nInitializing algorithms...")

    # Example: Use path planning algorithm
    # planner = PathPlanning()
    # path = planner.execute(start=(0, 0), goal=(10, 10))

    print("\\nSimulation complete!")
    print("\\nTo use these algorithms in your code:")
    print("  from algorithms import *")
    print("  algorithm = PathPlanning()")
    print("  result = algorithm.execute(...)")


if __name__ == '__main__':
    main()
"""

    def _generate_geometry_utils(self) -> str:
        """Generate geometry utility functions"""
        return """\"\"\"
Geometry Utility Functions

Common geometric calculations for robotics
\"\"\"

import numpy as np
from typing import Tuple


def distance(p1: Tuple[float, float], p2: Tuple[float, float]) -> float:
    \"\"\"
    Calculate Euclidean distance between two points

    Args:
        p1: First point (x, y)
        p2: Second point (x, y)

    Returns:
        Distance between points
    \"\"\"
    return np.sqrt((p2[0] - p1[0])**2 + (p2[1] - p1[1])**2)


def normalize_angle(angle: float) -> float:
    \"\"\"
    Normalize angle to [-pi, pi]

    Args:
        angle: Angle in radians

    Returns:
        Normalized angle
    \"\"\"
    while angle > np.pi:
        angle -= 2 * np.pi
    while angle < -np.pi:
        angle += 2 * np.pi
    return angle


def angle_between(p1: Tuple[float, float], p2: Tuple[float, float]) -> float:
    \"\"\"
    Calculate angle from p1 to p2

    Args:
        p1: Start point (x, y)
        p2: End point (x, y)

    Returns:
        Angle in radians
    \"\"\"
    return np.arctan2(p2[1] - p1[1], p2[0] - p1[0])


def rotate_point(point: Tuple[float, float], angle: float, origin: Tuple[float, float] = (0, 0)) -> Tuple[float, float]:
    \"\"\"
    Rotate point around origin

    Args:
        point: Point to rotate (x, y)
        angle: Rotation angle in radians
        origin: Center of rotation

    Returns:
        Rotated point (x, y)
    \"\"\"
    # Translate to origin
    x = point[0] - origin[0]
    y = point[1] - origin[1]

    # Rotate
    cos_a = np.cos(angle)
    sin_a = np.sin(angle)
    x_new = x * cos_a - y * sin_a
    y_new = x * sin_a + y * cos_a

    # Translate back
    return (x_new + origin[0], y_new + origin[1])


def line_circle_intersection(
    line_start: Tuple[float, float],
    line_end: Tuple[float, float],
    circle_center: Tuple[float, float],
    circle_radius: float
) -> bool:
    \"\"\"
    Check if line segment intersects circle

    Args:
        line_start: Start of line segment
        line_end: End of line segment
        circle_center: Center of circle
        circle_radius: Radius of circle

    Returns:
        True if intersection exists
    \"\"\"
    # Vector from line start to circle center
    dx = circle_center[0] - line_start[0]
    dy = circle_center[1] - line_start[1]

    # Line direction vector
    lx = line_end[0] - line_start[0]
    ly = line_end[1] - line_start[1]

    # Project circle center onto line
    line_length_sq = lx**2 + ly**2
    if line_length_sq == 0:
        # Line is a point
        return distance(line_start, circle_center) <= circle_radius

    t = max(0, min(1, (dx * lx + dy * ly) / line_length_sq))

    # Closest point on line
    closest_x = line_start[0] + t * lx
    closest_y = line_start[1] + t * ly

    # Check distance
    dist = distance((closest_x, closest_y), circle_center)
    return dist <= circle_radius
"""
